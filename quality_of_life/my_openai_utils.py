
from quality_of_life.my_base_utils import load_txt, support_for_progress_bars
from quality_of_life.ansi import bcolors

import sys
import traceback
from openai import OpenAI

#
# ~~~ https://stackoverflow.com/a/10446010/11595884
class Meta(type):
    def __contains__(cls, item):
        return item in cls.set

class BaseSequence(metaclass=Meta):
    pass

class EndSequences(BaseSequence):
    set = set([ "Exit", "exit", "Quit", "quit", "q" ])
    @classmethod
    def append(cls,new_item):
        cls.set = cls.set | set(new_item)

#
# ~~~ Connect to my openai account (looks for "openaiapikey.txt" in the directory where Python.exe is located)
client = OpenAI( api_key=load_txt("openaiapikey.txt",True) )

#
# ~~~ Wrap text completion
def get_next_response( conversation_log, context=False ):
    reponse_including_context = client.chat.completions.create(
            model="gpt-3.5-turbo",  # gpt-3.5-turbo
            messages = conversation_log,
            temperature = 1.5,
            max_tokens = 100,
            frequency_penalty = 0.9, 
            presence_penalty = 0.6, 
            top_p = 1.
        )
    return reponse_including_context if context else reponse_including_context.choices[0].message.content

# #
# # ~~~ The example from https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models
# example_conversation = [
#         {"role": "system", "content": "You are a crazy, unpredictable, and funny assistant, even if that means being offensive."},
#         {"role": "user", "content": "Knock knock."},
#         {"role": "assistant", "content": "Who's there?"},
#         {"role": "user", "content": "Orange."}
#     ]
# get_next_response(example_conversation) # ~~~ currently returns "Orange who?"

#
# ~~~ Given an error, color it red, and add a snarky comment generated by chat-gpt
def snarky_excepthook( type, value, traceback_obj ):
    #
    # ~~~ Get the original error message
    error_message = ''.join(traceback.format_exception(type, value, traceback_obj))
    try:
        #
        # ~~~ Extract the traceback to get the specific file and line numbers
        tb_summary = traceback.extract_tb(traceback_obj)
        #
        # ~~~ Get the last frame (the one that caused the error)
        last_frame = tb_summary[-1]
        filename, line_number, func_name, text = last_frame
        #
        # ~~~ This only works if the error occurred in a "real file," not the interactive console <stdin>
        #
        # ~~~ Read the source code from the file
        with open(filename,"r") as file:
            lines = file.readlines()
        #
        # ~~~ Get the lines surrounding the error, within a safe range
        start_line = max( 0, line_number-10 )       # ~~~ 10 lines before the error
        end_line = min( len(lines), line_number+1 ) # ~~~ 1 line after the error
        #
        # ~~~ Combine these lines into a string for display
        code_snippet = ''.join(lines[start_line:end_line])
        #
        # ~~~ Get chat-gpt to say something about the code snippet and the error
        snarky_prompt = compile_system_prompt([
            "You are snarky and condescending.",
            "Your goal is to make the user feel stupid.",
            "You fucking love to swear.",
            # "You are not allowed to say anything nice.",
            # "You are not allowed to say anything that could be interpreted as helpful.",
            "Your job is to criticize the user's dumbass Python code, which resulted in an error.",
            code_snippet,
            error_message.rstrip(),
            "Your commentary should take into account the specifics of this user's code."
        ])
        snarky_prompt.append({ "role":"user", "content":"Please make fun of me." })
        snarky_comment = cut_off_incomplete_sentence(get_next_response(snarky_prompt))                           
        #
        # ~~~ Append the code snippet to the error message
        modified_error_message = (bcolors.FAIL + error_message.rstrip() + "\n\n" +
                                  snarky_comment + bcolors.ENDC + " \U0001F62D")
    except:
        #
        # ~~~ Fallback in case the traceback is empty or missing
        modified_error_message = bcolors.FAIL + error_message.rstrip() + bcolors.ENDC + " \U0001F62D"
    #
    # ~~~ Print the modified error message
    print(modified_error_message, file=sys.stderr)

#
#~~~ Override the default excepthook with the custom_excepthook
def snarky_errors():
    sys.excepthook = snarky_excepthook     # ~~~ not reversible without resatring the python terminal

#
# ~~~ Format a simple list of text strings into a colorful printed message log
def format_messages(
        list_of_messages,
        user_name = "User",
        assistant_name = "Bot",
        role_color = bcolors.HEADER,
        content_color = (sys.stdout.main_color if hasattr(sys.stdout,"main_color") else bcolors.OKGREEN),
        end = "print",
        buffer = 1,
        suffix = ":",
        separator = " ",
        between_lines = "\n"+bcolors.OKBLUE+"--------------\n"
    ):
    #
    # ~~~ Boiler plate stuff
    assert end=="print" or end=="return"
    user_name = "user" if (user_name is None) else user_name
    assistant_name = "Bot" if (assistant_name is None) else assistant_name
    expected_roles = [ user_name, assistant_name ]
    just_val = max([ len(role) for role in expected_roles ]) + len(suffix)
    formatted_output = ""
    #
    # ~~~ Loop through the list `list_of_messages` and execute the relevant logic on each item
    with support_for_progress_bars():
        for j,dictionary in enumerate(list_of_messages):
            if j>0:
                formatted_output += between_lines
            formatted_output += format_line(
                role = dictionary["role"],
                content = dictionary["content"],
                just_val = just_val,
                user_name = user_name,
                assistant_name = assistant_name,
                role_color = role_color,
                content_color = content_color,
                buffer = buffer,
                suffix = suffix,
                separator = separator
            )
        #
        # ~~~ Output
        formatted_output = formatted_output.strip("\n")   # ~~~ we don't actually want that last line breack
        if end=="return":
            return formatted_output
        else:
            print(formatted_output)

#
# ~~~ Sub-routine that formats a single line of text
def format_line(
        role,
        content,
        just_val,
        user_name = "User",
        assistant_name = "Bot",
        role_color = bcolors.HEADER,
        content_color = (sys.stdout.main_color if hasattr(sys.stdout,"main_color") else bcolors.OKGREEN),
        buffer = 0,
        suffix = ":",
        separator = " "
    ):
    if role=="user" and user_name is not None:
        role = user_name
    if role=="assistant" and assistant_name is not None:
        role = assistant_name
    name = role_color+(role+suffix).rjust(just_val)
    text = content_color+content
    space_in_between = " "*buffer+bcolors.HEADER+separator+" "*buffer
    return name + space_in_between + text

#
# ~~~ In case the token limit ends us mid-sentence, strip down to the last complete sentence
def cut_off_incomplete_sentence(text):
    #
    # ~~~ Find the last occurrence of '.' or '!'
    last_punctuation = max(text.rfind('.'),text.rfind('!'))
    return text if last_punctuation == -1 else text[:last_punctuation + 1]

#
# ~~~ Format a list of text strings (instructions ot the bot) in the format which OpenAI expects
def compile_system_prompt(list_of_text_strings):
    return [
            { "role":"system", "content":text_string }
            for text_string in list_of_text_strings
        ]

#
# ~~~ Wrap the get_next_response() function in a loop that keeps asking the user for input until the user enters one of the EndSequences
def interactive_chatbot(
        completer,
        system_prompt,
        end_sequences = EndSequences,
        user_prompt = "You",
        assistant_name = "Bot",
        role_color = bcolors.HEADER,
        content_color = (sys.stdout.main_color if hasattr(sys.stdout,"main_color") else bcolors.OKGREEN),
        buffer = 0,
        suffix = ":",
        separator = " ",
        between_lines = bcolors.OKBLUE+"-------------------"
    ):
    #
    # ~~~ Initialization
    system_prompt = system_prompt if isinstance( system_prompt[0], dict ) else compile_system_prompt(system_prompt)
    message_log = system_prompt
    expected_tags = [ user_prompt, assistant_name ]
    just_val = max([ len(role) for role in expected_tags ]) + len(suffix)
    print("")
    print(f"    Enter one of the EndSequences to end the conversation: {EndSequences.set}")
    print("")
    #
    # ~~~ Wrap a frequently called text formatting util
    def my_format( role, content ):
        return format_line(
                role,
                content,
                just_val = just_val,
                assistant_name = assistant_name,
                role_color = role_color,
                content_color = content_color,
                buffer = buffer,
                suffix = suffix,
                separator = separator
            )
    #
    # ~~~ Implement the actual logic of the conversation between user and bot
    while True:
        #
        # ~~~ Get the input from the user, print it in the terminal and update `messages` to include the bot response
        user_input = input(my_format( role=user_prompt, content="" ))  # ~~~ both gets the input and prints it, too
        message_log.append({ "role":"user", "content":user_input })    # ~~~ add it to the record
        print(between_lines)
        #
        # ~~~ If user says `exit` or one of the other end_sequences, exit the loop
        if user_input in end_sequences:
            print(my_format( role="Interrupt Sequence", content=user_input ))
            break
        #
        # ~~~ Get the response from the bot, print it in the terminal, and update `message_log` to include the last bot response
        bot_response = completer(message_log)                               # ~~~ gets the response
        print(my_format( role="assistant", content=bot_response ))          # ~~~ print it
        message_log.append({ "role":"assistant", "content":bot_response })  # ~~~ add it to the record
        print(between_lines)
    #
    # ~~~ return the log of events; try, e.g., `format_messages(message_log)`
    return message_log

#


def provoke_error():
    print("About to divide by zero!")
    1 / 0  # This will cause a ZeroDivisionError
    print("This line will not be reached.")
